Индексы — это средство увеличения производительности БД. 


CREATE TABLE test1 (
    id integer,
    content varchar
);

Обычно при поиске таблица сканирует все строки, чтобы найти нужный результат. Если мы часто выполняем одинаковые запросы, подобно этому,
это становится неээфективно.

SELECT content FROM test1 WHERE id = константа;

Если создать индекс по полю id - система будет работать быстрее. (Это как в книге:  термины и понятия, которые могут представлять интерес, 
собираются в алфавитном указателе в конце книги. Читатель может просмотреть этот указатель довольно быстро и затем перейти сразу к 
соответствующей странице, вместо того, чтобы пролистывать всю книгу в поисках нужного материала.)
SQL анализирует все возможные пути выполнения запроса и выбирает оптимальный. Каждый путь называется ПЛАН ВЫПОЛНЕНИЯ, а компонент, занимающийся
этим называется ОПТИМИЗАТОРОМ ЗАПРОСОВ.

Создать индекс или его удалить: 

CREATE INDEX test1_id_index ON test1 (id);
test1_id_index - имя индекса
test1 - имя таблицы
(id) - столбцы

DROP INDEX test1_id_index

По умолчанию PostgreSQL позволяет параллельно с созданием индекса выполнять чтение (операторы SELECT) таблицы, но операции записи (INSERT, UPDATE и DELETE) 
блокируются до окончания построения индекса. 
Минусы в том, что при изменениях данных в таблице (INSERT, DELETE, UPDATE) индекс тоже будет обновляться. То есть эти операции займут больше времени.
Так же кушает много места. 
Индексы могут быть:
1) кластеризованные
- по умолчанию вешается на PRIMARY KEY при его определнии, использует бинарный поиск (HASH)
2) декластеризованные
- все, что не к PRIMARY KEY
- требует явного объявления
- хранится отдельно от данных таблиц



ТИПЫ ИНДЕКСОВ
Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы индексируемых предложений. По умолчанию команда CREATE INDEX создаёт 
индексы-B-деревья, эффективные в большинстве случаев. Выбрать другой тип можно, написав название типа индекса после ключевого слова USING.

1) b-дерево
- поддерживает 
<   
<=  
=   
>=   
> 
BETWEEN  
IN
IS NULL 
IS NOT NULL
LIKE
~
- лучше всего для: числа, строки, упорядоченные данные, точные значения или диапазоны
- сложность поиска О(logN)


2) HASH
CREATE INDEX имя ON таблица USING HASH (столбец);
- поддерживает
=
- лучше всего для: точный поиск (=) на уникальных значениях
- сложность поиска О(1) - моментально

3) GiST
-  поддерживает
<<   
&<   
&>   
>>   
<<|   
&<|   
|&>   
|>>   
@>   
<@   
~=   
&&
- лучше всего для: диапазонов, геометрическе и географические типы данных (так как поддерживает диапазоны и перекрытия)
- занимает меньше места

4) SP-GiST
- поддерживает
<<   
>>   
~=   
<@   
<<|   
|>>
- лучше всего для: 

5) GIN
- поддерживает
<@   
@>   
=  
&&
- лучше всего для: поиска наличия значений в коллекциях, документах
- GIN-индексы представляют собой «инвертированные индексы», в которых могут содержаться значения с несколькими ключами, 
например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно 
работать в запросах, проверяющих присутствие определённых значений компонентов.

6) BRIN (сокращение от Block Range INdexes, Индексы зон блоков)
- поддерживает
<   
<=   
=   
>=   
>
- лучше всего для: больших таблиц с данными, которые логически упорядочены, например временные ряды или лог-файлы, так как 
BRIN индексы хранят минимальные и максимальные значения для каждого блока данных.
- потребляет меньше всех памяти



СОСТАВНЫЕ ИНДЕКСЫ

CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);

Индексы можно создавать и по нескольким столбцам таблицы. Например если есть частый запрос по двум столбцам сразу, можно
создать составной индекс: 

CREATE INDEX test2_mm_idx ON test2 (major, minor);

В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Число столбцов в индексе ограничивается 32, 
включая столбцы INCLUDE. (Этот предел можно изменить при компиляции PostgreSQL)
Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и 
сэкономит время и место. Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно.



ИНДЕКСЫ И ПРЕДЛОЖЕНИЯ ORDER BY 
Помимо простого поиска строк для выдачи в результате запроса, индексы также могут применяться для сортировки строк в определённом порядке. 
Это позволяет учесть предложение ORDER BY в запросе, не выполняя сортировку дополнительно. Из всех типов индексов, которые поддерживает
PostgreSQL, сортировать данные могут только B-деревья — индексы других типов возвращают строки в неопределённом, зависящем от реализации порядке.
Планировщик может выполнить указание ORDER BY, либо просканировав существующий индекс, подходящий этому указанию, либо просканировав таблицу в 
физическом порядке и выполнив сортировку явно.
При сочетании ORDER BY с LIMIT n: при явной сортировке системе потребуется обработать все данные, чтобы выбрать первые n строк, но при наличии индекса, 
соответствующего столбцам в ORDER BY, первые n строк можно получить сразу, не просматривая остальные вовсе.
По умолчанию элементы B-дерева хранятся в порядке возрастания, при этом значения NULL идут в конце. Это поведение по умолчанию можно изменить при
создании индекса

CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);